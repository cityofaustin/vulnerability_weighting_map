quintile = function(x) {
  qn = quantile(x, probs = (0:5)/5)
  result = as.numeric(cut(x, qn, include.lowest = T)) # https://stackoverflow.com/questions/39693957/calculating-quintile-based-scores-on-r
}

cv_interp <- function(cv) {
  ret <- case_when(cv == 0 | cv > 0.4 ~ "3. Not reliable", ## TODO Allow function to take in MOE as well, because when CV is 0 it isn't ALWAYS a MOE issue
                   cv >= 0.2 & cv < 0.4 ~ "2. Use caution",
                   cv < 0.2 ~ "1. Reliable",
                   is.na(cv) ~ "3. Not reliable")
}

moe_chgprop <- function(moe_y1, moe_y2, est_y1, est_y2) {
  ## Calculate moe for change in proportions
  moe <- (sqrt(moe_y2 ^ 2 + (est_y2 / est_y1) ^ 2 * moe_y1 ^ 2 )) / est_y1
  return(moe)
}

sig_test <- function(est_y1, est_y2, moe_y1, moe_y2, output = "bool") {
  ## Determine if there is a difference between two numbers; TRUE values are significant at 90% confidence
  se1 <- moe_y1 / 1.645
  se2 <- moe_y2 / 1.645
  test <- abs((est_y1 - est_y2) / sqrt(se1 ^ 2 + se2 ^ 2))
  significant <- test > 1.645
  
  if(output == "num") {
    return(as.numeric(significant))
  } else {
    return(significant)
  }
}

overlap_se <- function(y1, y2, moe_y1, moe_y2) {
  se1 <- moe_y1 / 1.645
  se2 <- moe_y2 / 1.645
  c <- (y2 - y1) / 5
  sex1x2 <- sqrt(1 - c) * sqrt(se1 ^ 2 + se2 ^ 2)
  return(sex1x2)
}

overlap_moe <- function(y1, y2, moe_y1, moe_y2) {
  se1 <- moe_y1 / 1.645
  se2 <- moe_y2 / 1.645
  c <- (y2 - y1) / 5
  sex1x2 <- sqrt(1 - c) * sqrt(se1 ^ 2 + se2 ^ 2)
  moe <- sex1x2 * 1.645
  return(moe)
}