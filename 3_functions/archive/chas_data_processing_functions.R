extract_fips <- function(geoid, sumlevel){
  ## Extract FIPS code from geoid provided a sumlevel
  ## TODO Add all relevant sumlevels and substrings
  fips <- case_when(sumlevel == 80 ~ paste0(substr(geoid, 8, 12), substr(geoid, 23, 29)),
                    sumlevel == 140 ~ substr(geoid, 8,20),
                    sumlevel == 160 ~ substr(geoid, 8,14),
                    TRUE ~ geoid)
  return(fips)
}

drop_cols <- function(chastable) {
  ## Drops all unnecessary columns except GEOID and name
  ## TODO Add other sumlevel types
  chastable$sumlevel <- as.numeric(chastable$sumlevel)
  sumlevel <- chastable$sumlevel[1]
  
  if(sumlevel == 140) {
    ret <- chastable %>% select(GEOID, year, everything(), -c(source, sumlevel, geoid, st, cnty, tract))
    return(ret)
  } else if(sumlevel == 160) {
    ret <- chastable %>% select(GEOID, year, everything(), -c(source, sumlevel, geoid, st, place))
    return(ret)
  } else if(sumlevel == 80) {
    ret <- chastable %>% select(GEOID, year, everything(), -c(source, sumlevel, geoid))
    return(ret)
  } else{
    break()
  }
}

clean_chas <- function(csvpath, year, filter_statement) {
  ## Read in and clean CHAS data under the current vintage (sumlevel 140 for tracts instead of 080 for tracts)
  year <- year
  raw_chastable <- read_csv(csvpath)
  
  raw_chastable %>%
    mutate(year = year,
           GEOID = extract_fips(geoid, sumlevel)) %>%
    drop_cols(.) %>%
    pivot_longer(-c(GEOID, year, name),
                 names_to = c("table", "type", "varnum"),
                 names_pattern = "T(\\d+)_(est|moe)(\\d+)",
                 values_to = "value") %>% 
    pivot_wider(names_from = "type", values_from = "value") %>%
    mutate(table = as.numeric(table),
           varnum = as.numeric(varnum)) %>%
    filter(eval(rlang::parse_expr(filter_statement)))
}

vintage_clean_chas <- function(csvpath, year, filter_statement) {
  ## Read in and clean CHAS data under the older vintage (sumlevel 080 for tracts), which
  ## splits census tracts by place-county segments. This requires re-summing the records to 
  ## the census tract level and re-calculating the margins of error. Sumlevel 080 was 
  ## discontinued in 2013.
  year <- year
  raw_chastable <- read_csv(csvpath)
  sumlevel <- as.numeric(substr(raw_chastable$geoid[1], 1, 3))
  
  ret <- raw_chastable %>%
    mutate(year = year,
           sumlevel = substr(geoid, 1, 3),
           name = NA_character_,
           GEOID = extract_fips(geoid, as.numeric(sumlevel))) %>%
    drop_cols(.) %>%
    pivot_longer(-c(GEOID, year, name),
                 names_to = c("table", "type", "varnum"),
                 names_pattern = "T(\\d+)_(est|moe)(\\d+)",
                 values_to = "value") %>% 
    pivot_wider(names_from = "type", values_from = "value") %>%
    mutate(table = as.numeric(table),
           varnum = as.numeric(varnum)) %>%
    filter(eval(rlang::parse_expr(filter_statement)))
  
  if(sumlevel == 80) {
    ret <- ret %>%
      group_by(GEOID, year, name, table, varnum) %>%
      mutate(newest = sum(unlist(est), na.rm = T),
             newmoe = moe_sum(unlist(moe), estimate = newest)) %>% ungroup() %>%
      select(GEOID, year, name, table, varnum, est = newest, moe = newmoe) %>%
      mutate(moe = case_when(est == 0 ~ 22, ## Hard-code MoE to 22 for zero estimates. Needs more thought. Rationale is that MoEs are not coded right at 080 sumlevel
                             TRUE ~ moe)) ## However this doesn't seem to work...
  } else if(sumlevel == 160) {
    ret <- ret %>% select(GEOID, year, name, table, varnum, est, moe)
  } else {
    break()
  }
  
  return(ret)
}

get_li <- function(t8) {
  
  vars2collapse <- c(3, 16, 29, 69, 82, 95)
  
  base <- t8 %>% 
    filter(table == 8, varnum == 1) %>% 
    mutate(var = "lihhbase", param = "ttl") %>%
    select(GEOID, year, param, var, est, moe)
  
  ttl <- t8 %>%
    filter(table == 8,
           varnum %in% vars2collapse) %>%
    group_by(GEOID, year) %>%
    summarize(est = sum(est, na.rm = T),
              moe = moe_sum(moe, est)) %>% ungroup() %>%
    mutate(param = "ttl", var = "lihh") %>%
    select(GEOID, year, param, var, est, moe)
  
  pct <- rbind(ttl, base) %>%
    group_by(GEOID, year) %>%
    mutate(pct = est / est[var == "lihhbase"],
           denom_est = est[var == "lihhbase"],
           denom_moe = moe[var == "lihhbase"],
           pct_moe = moe_prop(num = est, denom = denom_est, 
                              moe_num = moe, moe_denom = denom_moe),
           var = "lihh",
           param = "pct") %>% ungroup() %>% filter(pct != 1) %>%
    select(GEOID, year, param, var, est=pct, moe=pct_moe)
  
  df <- rbind(pct, ttl, base)
  
  return(df)
}

read_extract <- function(path, year, filter_statement, sumlevel = "plc") {
  path <- path
  year <- year
  filter_statement <- filter_statement
  
  ## If the sumlevel is tract and the year is before 2013, then use the vintage_clean_chas function
  ## Otherwise, use the current clean_chas function
  if(year < 2013 & sumlevel == "tct") {
    df <- vintage_clean_chas(csvpath = path, year = year, 
                             filter_statement = filter_statement) %>%
      get_li(.)
  } else {
    df <- clean_chas(csvpath = path, year = year, 
                     filter_statement = filter_statement) %>%
      get_li(.)
  }
  return(df)
  
}

set_geo_tags_tct <- function(sumlevel80chastable) {
  ret <- sumlevel80chastable %>%
    janitor::clean_names() %>%
    mutate(county = substr(sum080, start = 1, stop = 5),
           cosub = substr(sum080, start = 6, stop = 10),
           coplace = substr(sum080, start = 11, stop = 15),
           tract = substr(sum080, start = 16, stop = 21),
           GEOID = paste0(county, tract))
  return(ret)
}

set_geo_tags_plc <- function(sumlevel155chastable) {
  ret <- sumlevel155chastable %>%
    janitor::clean_names() %>%
    mutate(county = substr(sum155, start = 8, stop = 10)) %>%
    rename(GEOID = placecd)
  return(ret)
}

read_clean_chas_00 <- function(filepath, table, sumlevel){
  chas <- rio::import(filepath) 
  
  if(sumlevel == "080") {
    chas <- set_geo_tags_tct(chas) %>%
      mutate(sumlevel = "tract")
  }
  if(sumlevel == "155") {
    chas <- set_geo_tags_plc(chas) %>%
      mutate(sumlevel = "place")
  }
  
  chas %>%
    group_by(GEOID, sumlevel) %>%
    summarize(across(.cols = c(1:total), .fns = sum, na.rm = T)) %>%
    pivot_longer(-c(GEOID, sumlevel), names_to = "variable", values_to = "estimate") %>%
    mutate(varnum = str_replace(variable, table, ""),
           varnum = str_replace(varnum, "total", "0"),
           varnum = as.numeric(varnum),
           moe = 0,
           table = toupper(table))
}