##### Typology functions ####


###### HOUSING MARKET ##########
##### Spatial functions #####
## Determines if a given FIPS code is a hot tract
is_hot <- function(fips, df) {
  df %>% 
    # st_drop_geometry() %>% 
    dplyr::filter(GEOID == fips) %>% dplyr::pull(is_hot) %>% as.logical()
}

## Accepts vector of FIPS codes to see if any of them are hot
any_neighbor_hot <- function(fipss, df) {
  df <- df
  nb_cond <- unlist(lapply(fipss, is_hot, df = df))
  if(TRUE %in% nb_cond) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}

## Uses attributes of neighbor matrix with assigned region IDs to feed in a row number and return the region ID (or FIPS code in this case)
rn2fips <- function(rn, nb) {
  attr(nb, "region.id")[rn]
}

## Returns a tract's neighbors vector by using neighbor matrix and the original sf object with assigned row numbers
get_neighbors <- function(fips, nb, rn.sf) {
  asrn <- rn.sf %>% filter(GEOID == fips) %>% pull(rn)
  # message(paste0("Row number of this tract in the `msa.sf` object is ", asrn))
  lapply(nb[asrn], rn2fips, nb = nb)[[1]]
}




## Calculates market change between two input years
get_market_change_city <- function(summary, year1, year2, year0base = 2000, sub_prop) {
  y1c <- year1
  y2c <- year2
  y0c <- year0base
  
  y1 <- summary %>% filter(year == y1c, sub_prop_rec == sub_prop ) #,touches_pdx == TRUE)
  y2 <- summary %>% filter(year == y2c, sub_prop_rec == sub_prop ) %>% st_drop_geometry() #,touches_pdx == TRUE) %>% st_drop_geometry()
  y0 <- summary %>% filter(year == y0c, sub_prop_rec == sub_prop ) %>% st_drop_geometry() #,touches_pdx == TRUE) %>% st_drop_geometry()
  
  chg_y0ty2 <- inner_join(y0, y2, by = c("GEOID", "sub_prop_rec"), suffix = c(paste0(".",y0c), paste0(".", y2c))) %>%
    mutate(in_pdx = !!sym(paste0("in_pdx.", y0c)),
           touches_pdx = !!sym(paste0("touches_pdx.", y0c)),
           vicinity = !!sym(paste0("vicinity.", y0c)),
           tctname = !!sym(paste0("tctname.", y0c)),
           y0 = y0c,
           y2 = y2c,
           ydif = y2 - y0,
           y0_sales = !!sym(paste0("count_sales.", y0c)),
           y2_sales = !!sym(paste0("count_sales.", y2c)),
           y0_mhv = !!sym(paste0("pctile_50th.", y0c)),
           y2_mhv = !!sym(paste0("pctile_50th.", y2c)),
           sub_prop_rec = sub_prop_rec,
           cagr_mhv_pct50 = (!!sym(paste0("pctile_50th.", y2c)) / !!sym(paste0("pctile_50th.", y0c))) ^ (1 / ydif) - 1) %>%
    group_by(sub_prop_rec) %>% #in_pdx, ## Add in "in_pdx" to calculate the numbers for those that are within Portland Only; leave it out for regional housing market
    filter(y0_sales > 6, y2_sales > 6) %>% ## Want at least 7 sales in both years
    mutate(qn_cagr_mhv_pct50 = ntile(cagr_mhv_pct50, 100),
           qn_y0_hmv = ntile(y0_mhv, 100),
           had_hi_val_base = if_else(qn_y0_hmv >= 60, TRUE, FALSE),
           had_hi_appr_base = if_else(qn_cagr_mhv_pct50 >= 60, TRUE, FALSE)) %>% # High appreciation rate?
    ungroup() %>%
    select(GEOID, sub_prop_rec, y0, y0_sales, y0_mhv, had_hi_val_base, had_hi_appr_base)
  
  
  chg_y1ty2 <- inner_join(y1, y2, by = c("GEOID", "sub_prop_rec"), suffix = c(paste0(".",y1c), paste0(".", y2c))) %>%
    left_join(., chg_y0ty2, by = c("GEOID", "sub_prop_rec")) %>%
    mutate(in_pdx = !!sym(paste0("in_pdx.", y1c)),
           touches_pdx = !!sym(paste0("touches_pdx.", y1c)),
           vicinity = !!sym(paste0("vicinity.", y1c)),
           tctname = !!sym(paste0("tctname.", y1c)),
           y1 = y1c,
           y2 = y2c,
           ydif = y2 - y1,
           y1_sales = !!sym(paste0("count_sales.", y1c)),
           y2_sales = !!sym(paste0("count_sales.", y2c)),
           y1_mhv = !!sym(paste0("pctile_50th.", y1c)),
           y2_mhv = !!sym(paste0("pctile_50th.", y2c)),
           y1_ratio_pdx= !!sym(paste0("ratio_pdx.", y1c)),
           y2_ratio_pdx = !!sym(paste0("ratio_pdx.", y2c)),
           chg_count_sales = (y2_sales - y1_sales) / (y1_sales),
           cagr_count_sales = (y2_sales / y1_sales) ^ (1 / ydif) - 1,
           sub_prop_rec = sub_prop_rec,
           cagr_mhv_pct50 = (!!sym(paste0("pctile_50th.", y2c)) / !!sym(paste0("pctile_50th.", y1c))) ^ (1 / ydif) - 1) %>%
    # select(GEOID, in_pdx, touches_pdx, tctname, vicinity, y1:cagr_count_sales, sub_prop_rec, chg_mhv_pct05:cagr_mhv_ppsf_pct95) %>%
    group_by(sub_prop_rec, in_pdx) %>% ## Group by in_pdx in order to make the quantiles work for only pdx tracts, not bordering tracts (which are only used for neighbor value calculation)
    filter(y1_sales > 6, y2_sales > 6) %>% ## Want at least 7 sales in both years
    mutate(qn_cagr_mhv_pct50 = ntile(cagr_mhv_pct50, 100),
           qn_y2_ratio_pdx = ntile(y2_ratio_pdx, 100), ## Use ratio of tract-to-PDX home values
           has_hi_val = if_else(qn_y2_ratio_pdx >= 60, TRUE, FALSE), ## High present value?
           has_hi_appr = if_else(qn_cagr_mhv_pct50 >= 60, TRUE, FALSE), # High appreciation rate?
           is_hot = if_else(has_hi_val == T | has_hi_appr == T, TRUE, FALSE)) %>% # Either high present value or appreciation rate? <- This is the most important variable
    ungroup()
}


## The only difference between market_change_region vs city is the grouping variable. The 
## region model excludes "in_pdx" from grouping variable so that the entire regional housing 
## market is the base instead of just Portland tracts. This does not yet include rental market,
## only for-sale market.
get_market_change_region <- function(summary, year1, year2, year0base = 2000, sub_prop) {
  y1c <- year1
  y2c <- year2
  y0c <- year0base
  
  y1 <- summary %>% filter(year == y1c, sub_prop_rec == sub_prop ) #,touches_pdx == TRUE)
  y2 <- summary %>% filter(year == y2c, sub_prop_rec == sub_prop ) %>% st_drop_geometry() #,touches_pdx == TRUE) %>% st_drop_geometry()
  y0 <- summary %>% filter(year == y0c, sub_prop_rec == sub_prop ) %>% st_drop_geometry() #,touches_pdx == TRUE) %>% st_drop_geometry()
  
  chg_y0ty2 <- inner_join(y0, y2, by = c("GEOID", "sub_prop_rec"), suffix = c(paste0(".",y0c), paste0(".", y2c))) %>%
    mutate(in_pdx = !!sym(paste0("in_pdx.", y0c)),
           touches_pdx = !!sym(paste0("touches_pdx.", y0c)),
           vicinity = !!sym(paste0("vicinity.", y0c)),
           tctname = !!sym(paste0("tctname.", y0c)),
           y0 = y0c,
           y2 = y2c,
           ydif = y2 - y0,
           y0_sales = !!sym(paste0("count_sales.", y0c)),
           y2_sales = !!sym(paste0("count_sales.", y2c)),
           y0_mhv = !!sym(paste0("pctile_50th.", y0c)),
           y2_mhv = !!sym(paste0("pctile_50th.", y2c)),
           sub_prop_rec = sub_prop_rec,
           cagr_mhv_pct50 = (!!sym(paste0("pctile_50th.", y2c)) / !!sym(paste0("pctile_50th.", y0c))) ^ (1 / ydif) - 1) %>%
    group_by(sub_prop_rec) %>% #in_pdx, ## Add in "in_pdx" to calculate the numbers for those that are within Portland Only; leave it out for regional housing market
    filter(y0_sales > 6, y2_sales > 6) %>% ## Want at least 7 sales in both years
    mutate(qn_cagr_mhv_pct50 = ntile(cagr_mhv_pct50, 100),
           qn_y0_hmv = ntile(y0_mhv, 100),
           had_hi_val_base = if_else(qn_y0_hmv >= 60, TRUE, FALSE),
           had_hi_appr_base = if_else(qn_cagr_mhv_pct50 >= 60, TRUE, FALSE)) %>% # High appreciation rate?
    ungroup() %>%
    select(GEOID, sub_prop_rec, y0, y0_sales, y0_mhv, had_hi_val_base, had_hi_appr_base)
  
  
  chg_y1ty2 <- inner_join(y1, y2, by = c("GEOID", "sub_prop_rec"), suffix = c(paste0(".",y1c), paste0(".", y2c))) %>%
    left_join(., chg_y0ty2, by = c("GEOID", "sub_prop_rec")) %>%
    mutate(in_pdx = !!sym(paste0("in_pdx.", y1c)),
           touches_pdx = !!sym(paste0("touches_pdx.", y1c)),
           vicinity = !!sym(paste0("vicinity.", y1c)),
           tctname = !!sym(paste0("tctname.", y1c)),
           y1 = y1c,
           y2 = y2c,
           ydif = y2 - y1,
           y1_sales = !!sym(paste0("count_sales.", y1c)),
           y2_sales = !!sym(paste0("count_sales.", y2c)),
           y1_mhv = !!sym(paste0("pctile_50th.", y1c)),
           y2_mhv = !!sym(paste0("pctile_50th.", y2c)),
           y1_ratio_pdx= !!sym(paste0("ratio_pdx.", y1c)),
           y2_ratio_pdx = !!sym(paste0("ratio_pdx.", y2c)),
           chg_count_sales = (y2_sales - y1_sales) / (y1_sales),
           cagr_count_sales = (y2_sales / y1_sales) ^ (1 / ydif) - 1,
           sub_prop_rec = sub_prop_rec,
           cagr_mhv_pct50 = (!!sym(paste0("pctile_50th.", y2c)) / !!sym(paste0("pctile_50th.", y1c))) ^ (1 / ydif) - 1) %>%
    # select(GEOID, in_pdx, touches_pdx, tctname, vicinity, y1:cagr_count_sales, sub_prop_rec, chg_mhv_pct05:cagr_mhv_ppsf_pct95) %>%
    group_by(sub_prop_rec) %>% ## Group by in_pdx in order to make the quantiles work for only pdx tracts, not bordering tracts (which are only used for neighbor value calculation)
    filter(y1_sales > 6, y2_sales > 6) %>% ## Want at least 7 sales in both years
    mutate(qn_cagr_mhv_pct50 = ntile(cagr_mhv_pct50, 100),
           qn_y2_ratio_pdx = ntile(y2_ratio_pdx, 100), ## Use ratio of tract-to-PDX home values
           has_hi_val = if_else(qn_y2_ratio_pdx >= 60, TRUE, FALSE), ## High present value?
           has_hi_appr = if_else(qn_cagr_mhv_pct50 >= 60, TRUE, FALSE), # High appreciation rate?
           is_hot = if_else(has_hi_val == T | has_hi_appr == T, TRUE, FALSE)) %>% # Either high present value or appreciation rate? <- This is the most important variable
    ungroup()
}


## Accepts change summary from `get_market_change()` as well as a neighbor matrix and its base file to
## look at each record's neighbors' housing market values to see if they are hot, meaning high ratio or appreciated quicker
## TODO WHYTF do I have a for loop? This slows down performance--figure out how to do this in a tidy-er way.
## TODO Ensure sub_prop works correctly
examine_neighbors <- function(hm_change_summary, nb, rn.sf) {
  nb <- nb
  rn.sf <- rn.sf
  
  hmchg <- hm_change_summary %>% st_drop_geometry()
  
  for(row in 1:nrow(hmchg)){
    thisfips <- as.character(hmchg[row, 'GEOID'])
    # message(paste0("row: ", row, "  FIPS: ", thisfips))
    hmchg[row,'has_hot_neighbors'] <- any_neighbor_hot(get_neighbors(thisfips, nb = nb, rn.sf = rn.sf), df = hmchg)
  }
  
  hmchg <- left_join(hmchg, rn.sf %>% select(-in_pdx), by = "GEOID") %>% st_as_sf()
  
  return(hmchg)
}

assign_hm_typology <- function(hm_change_summary) {
  ret <- hm_change_summary %>%
    mutate(hm_typology = case_when(is_hot == FALSE & has_hot_neighbors == TRUE ~ "Adjacent",
                                   has_hi_val == FALSE & has_hi_appr == TRUE ~ "Accelerating",
                                   had_hi_val_base == FALSE & has_hi_val == TRUE & had_hi_appr_base == TRUE ~ "Appreciated",
                                   TRUE ~ NA_character_),
           hm_typology = ordered(hm_typology, levels = c("Adjacent", "Accelerating", "Appreciated")))
  return(ret)
}


collapse_market_change <- function(rmls_summary, year1, year2, year0base, city_region) {
  
  if(city_region == "City") {
    hm1 <- get_market_change_city(rmls_summary, 
                                  year1 = year1, year2 = year2, 
                                  year0base = year0base, sub_prop = "SFR") %>%
      examine_neighbors(., nb = msa.nbr, rn.sf = msa.sf) %>% 
      # filter(in_pdx == T) %>%
      assign_hm_typology(.)
    
    hm2 <- get_market_change_city(rmls_summary, 
                                  year1 = year1, year2 = year2, 
                                  year0base = year0base, sub_prop = "MFR") %>%
      examine_neighbors(., nb = msa.nbr, rn.sf = msa.sf) %>% 
      # filter(in_pdx == T) %>%
      assign_hm_typology(.)
  }
  
  else if(city_region == "Region") {
    hm1 <- get_market_change_region(rmls_summary, 
                                    year1 = year1, year2 = year2, 
                                    year0base = year0base, sub_prop = "SFR") %>%
      examine_neighbors(., nb = msa.nbr, rn.sf = msa.sf) %>% 
      # filter(in_pdx == T) %>%
      assign_hm_typology(.)
    
    hm2 <- get_market_change_region(rmls_summary, 
                                    year1 = year1, year2 = year2, 
                                    year0base = year0base, sub_prop = "MFR") %>%
      examine_neighbors(., nb = msa.nbr, rn.sf = msa.sf) %>% 
      # filter(in_pdx == T) %>%
      assign_hm_typology(.)
  }
  
  
  
  hm <- rbind(hm1, hm2) %>% group_by(GEOID) %>% top_n(., 1, y1_sales)
  
  return(hm)
}
